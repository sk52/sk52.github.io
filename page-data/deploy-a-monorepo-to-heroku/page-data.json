{"componentChunkName":"component---src-templates-blog-post-js","path":"/deploy-a-monorepo-to-heroku/","result":{"data":{"site":{"siteMetadata":{"title":"Always learning"}},"markdownRemark":{"id":"b6e6e2b4-ba32-51f2-b0f5-1559bbafd766","excerpt":"If you’ve ever thought about splitting your web application into more than one microservice whilst keeping them under the same GitHub repository, you may have…","html":"<p>If you’ve ever thought about splitting your web application into more than one microservice whilst keeping them under the same GitHub repository, you may have wondered how you can deploy each microservice to separate Heroku dynos with ease.</p>\n<p>In this blog post I’ll show you how to achieve this for a monorepo comprising two node.js applications using the <a href=\"https://elements.heroku.com/buildpacks/heroku/heroku-buildpack-multi-procfile\">Heroku Multi-Profile Buildpack</a>.</p>\n<h2>What and Why</h2>\n<p>Separating an application into several separate microservices has multiple benefits:</p>\n<ul>\n<li>Ability to separate a large and complex application into small and manageable services</li>\n<li>Developers can work on different parts of the application independent of each other</li>\n<li>Scaling the application can be done on a per-service basis</li>\n</ul>\n<p>Deploying a monolithic application to Heroku is simple enough, there’s plenty of information out there which <a href=\"https://devcenter.heroku.com/articles/getting-started-with-nodejs#set-up\">documents how</a>. For a monorepo it gets a little more complex. Read on to find out how.</p>\n<h2>Prerequisites</h2>\n<ul>\n<li>A heroku account (free tier works fine)</li>\n<li>Heroku CLI</li>\n<li>A monorepo structure containing two node.js projects as follows</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">example-app\n    --packages\n        |--client\n        |   |--package.json\n        |   |--package-lock.json\n        |\n        |--server\n            |--package.json\n            |--package-lock.json\n    --package.json\n    --package-lock.json</code></pre></div>\n<h2>How to</h2>\n<ol>\n<li>\n<p>Whilst logged in to Heroku create two new apps:</p>\n<ul>\n<li><code class=\"language-text\">example-app</code> - this will be our client application which end users access</li>\n<li><code class=\"language-text\">example-app-server</code> - this will be the server application which our client application integrates with</li>\n</ul>\n</li>\n<li>\n<p>In each application on Heroku, navigate to the settings tab and scroll down to “Buildpacks”. On each application we’ll add two buildpacks:</p>\n<ul>\n<li>First, add the multi-procfile buildpack by pasting this link - <code class=\"language-text\">https://github.com/heroku/heroku-buildpack-multi-procfile</code></li>\n<li>Next, add the <code class=\"language-text\">heroku/nodejs</code> buildpack</li>\n</ul>\n</li>\n<li>\n<p>Now we need to write our Procfiles and add these to their respective application folders</p>\n<ul>\n<li>What is a Procfile? It’s a file which specifies the commands to run when starting an application. Heroku uses this to fire up your application during deployment.</li>\n<li>In <code class=\"language-text\">packages/server</code> directory, run the command:</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"web: cd packages/server &amp;&amp; node server.js\"</span> <span class=\"token operator\">></span> Procfile</code></pre></div>\n<ul>\n<li>In <code class=\"language-text\">packages/client</code> directory, run the command</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">echo</span> <span class=\"token string\">\"web: cd packages/client &amp;&amp; node server.js\"</span> <span class=\"token operator\">></span> Procfile</code></pre></div>\n<ul>\n<li>Now we should be setup with both Procfiles which tell Heroku how to start our two applications</li>\n</ul>\n</li>\n<li>\n<p>Now, over in our repository we’ll need to use the Heroku CLI to specify our Profile locations, this lets Heroku know where to find the Procfiles.</p>\n<ul>\n<li>For this, we’ll use the names of our Heroku applications that we set in step 1</li>\n<li>Run the following commands:</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">heroku config:set -a example-app <span class=\"token assign-left variable\">PROCFILE</span><span class=\"token operator\">=</span>packages/client/Procfile</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">heroku config:set -a example-app-server <span class=\"token assign-left variable\">PROCFILE</span><span class=\"token operator\">=</span>packages/server/Procfile</code></pre></div>\n<ul>\n<li>Now Heroku knows where to find the Procfiles for our two applications</li>\n</ul>\n</li>\n<li>\n<p>Heroku now knows where to find our Procfiles, however, because we have two separate applications stored within the <code class=\"language-text\">client</code> and <code class=\"language-text\">server</code> directories, each has their own dependencies. Heroku typically tries to install dependencies as specified in the <code class=\"language-text\">package.json</code> at the root of the project, and similarly will try to run the build script specified here. To ensure we install the correct dependencies and run the correct build scripts for our application, we need to specify a <code class=\"language-text\">postinstall</code> script in the root of our project.</p>\n<ul>\n<li>In the <code class=\"language-text\">package.json</code> file in the project root, add the following scripts:</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">   <span class=\"token string\">\"scripts\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token punctuation\">{</span>\n       <span class=\"token string\">\"postinstall\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"if [ <span class=\"token variable\">$CLIENT_ENV</span> ]; then npm run postinstall-client; elif [ <span class=\"token variable\">$SERVER_ENV</span> ]; then npm run postinstall-server; else echo no environment detected, please set CLIENT_ENV or SERVER_ENV; fi\"</span>,\n       <span class=\"token string\">\"postinstall-client\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"cd packages/client &amp;&amp; npm install &amp;&amp; npm run build\"</span>,\n       <span class=\"token string\">\"postinstall-server\"</span><span class=\"token builtin class-name\">:</span> <span class=\"token string\">\"cd packages/server &amp;&amp; npm install\"</span>\n   <span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>We’ve added three scripts: <code class=\"language-text\">postinstall</code>, <code class=\"language-text\">postinstall-client</code>, and <code class=\"language-text\">postinstall-server</code></li>\n<li>Heroku will automatically run the <code class=\"language-text\">postinstall</code> script for us upon deployment</li>\n<li>Our postinstall script looks for environment variables <code class=\"language-text\">$CLIENT_ENV</code> or <code class=\"language-text\">$SERVER_ENV</code> to determine which postinstall script to run</li>\n</ul>\n</li>\n<li>\n<p>Finally, we need to go into the set two environment variables in our applications on Heroku</p>\n<ul>\n<li>Go to the Settings tab and scroll to Config Vars</li>\n<li>In the client application, add <code class=\"language-text\">CLIENT_ENV=true</code></li>\n<li>In the server application, add <code class=\"language-text\">SERVER_ENV=true</code></li>\n<li>Now our postinstall script will be able to run the correct install scripts for each of our applications on deployment</li>\n</ul>\n</li>\n<li>That’s it! Everything should now be set up to deploy multiple applications versioned under a monorepo to several Heroku applications. Just set your Heroku applications up to deploy on push and you should be ready to go next time you push changes.</li>\n</ol>\n<h2>Thoughts</h2>\n<p>This setup process provides a way of carrying out a monorepo deployment to Heroku whilst making use of the tools that Heroku offers. For more complex applications the deployment process may be better handled by a scripted pipeline using something like GitHub Actions. This would likely involve more steps, but could offer more control over the deployment process and gives the ability to incorporate it into a CI/CD pipeline which carries out unit testing and other quality steps.</p>","frontmatter":{"title":"Deploying a Monorepo to Heroku","tags":["Heroku","Monorepo"],"date":"May 01, 2021","description":null}},"previous":{"fields":{"slug":"/adding-github-actions-badge/"},"frontmatter":{"title":"Adding a GitHub Actions Status Badge to your README"}},"next":{"fields":{"slug":"/publishing-a-private-package-to-github/"},"frontmatter":{"title":"Publishing a Private Package to GitHub"}}},"pageContext":{"id":"b6e6e2b4-ba32-51f2-b0f5-1559bbafd766","previousPostId":"f5c97a4c-6a35-5f7c-a9bc-708dbbe59b7f","nextPostId":"d6f5ca23-b0a7-5993-b195-0bb5da62e64e"}},"staticQueryHashes":["230163734","2841359383"]}