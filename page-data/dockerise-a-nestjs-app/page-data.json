{"componentChunkName":"component---src-templates-blog-post-js","path":"/dockerise-a-nestjs-app/","result":{"data":{"site":{"siteMetadata":{"title":"Always learning"}},"markdownRemark":{"id":"dc88b96a-dac8-5934-8341-f3ce99217575","excerpt":"NestJS is a backend framework which aims to simplify server-side development by providing a consistent and abstract interface on top of the usual tools such as…","html":"<p>NestJS is a backend framework which aims to simplify server-side development by providing a consistent and abstract interface on top of the usual tools such as express. Like our recent <a href=\"/dockerise-a-react-app/\" target=\"_blank\">post</a> shows, dockerising applications is a useful approach to help streamline deployment processes. With NestJS this is no different, building a Docker image of your application’s production build can help. Keep reading to find out how.</p>\n<h2>What</h2>\n<p>We’ll be using <a href=\"https://docs.nestjs.com/\">NestJS</a> to create a basic web server.\nWe’ll also be using <a href=\"https://www.docker.com/\">Docker</a> to containerize the application, making it easy to run anywhere.</p>\n<h2>How</h2>\n<h3>Creating the Project</h3>\n<p>First, install the NestJS CLI globally: </p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">npm</span> i -g @nestjs/cli</code></pre></div>\n<p>Then, create a project:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">nest new nest-project</code></pre></div>\n<p>Once it’s complete, we should be able to run the application using <code class=\"language-text\">npm run start</code>, and see ‘Hello World!’ in our browser at localhost:3000</p>\n<p>If we want to run it in watch mode, so that the server restarts when we make any code changes, we can simply run <code class=\"language-text\">npm run start:dev</code> instead.</p>\n<p>This is simply the local dev version of the application. It is mostly used to give quick feedback whilst developing the application.</p>\n<h3>Creating the Dockerfile</h3>\n<p>Now, we’ll go ahead and create a Dockerfile: </p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">touch</span> Dockerfile</code></pre></div>\n<p>In that Dockerfile, we can add the following: </p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token keyword\">FROM</span> node<span class=\"token punctuation\">:</span>14<span class=\"token punctuation\">-</span>alpine AS builder\n\n<span class=\"token keyword\">WORKDIR</span> <span class=\"token string\">\"/app\"</span>\n\n<span class=\"token keyword\">COPY</span> . .\n\n<span class=\"token keyword\">RUN</span> npm ci\n\n<span class=\"token keyword\">RUN</span> npm run build\n\n<span class=\"token keyword\">RUN</span> npm prune <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span>production\n\n<span class=\"token keyword\">FROM</span> node<span class=\"token punctuation\">:</span>14<span class=\"token punctuation\">-</span>alpine AS production\n\n<span class=\"token keyword\">WORKDIR</span> <span class=\"token string\">\"/app\"</span>\n\n<span class=\"token keyword\">COPY</span> <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span>from=builder /app/package.json ./package.json\n<span class=\"token keyword\">COPY</span> <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span>from=builder /app/package<span class=\"token punctuation\">-</span>lock.json ./package<span class=\"token punctuation\">-</span>lock.json\n<span class=\"token keyword\">COPY</span> <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span>from=builder /app/dist ./dist\n<span class=\"token keyword\">COPY</span> <span class=\"token punctuation\">-</span><span class=\"token punctuation\">-</span>from=builder /app/node_modules ./node_modules\n\n<span class=\"token keyword\">CMD</span> <span class=\"token punctuation\">[</span> <span class=\"token string\">\"sh\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"-c\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"npm run start:prod\"</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>This Dockerfile has two parts to it, the first part is referred to as <code class=\"language-text\">builder</code> which you can see on the first line.\nThis step specifies our working directory as <code class=\"language-text\">/app</code>. </p>\n<p>Next, the package files are copied to the working directory, followed by an <code class=\"language-text\">npm run ci</code>.</p>\n<p>Next we run an <code class=\"language-text\">npm run build</code> command to build the production-ready code. This will place the built application code in the <code class=\"language-text\">/dist</code> folder within the working directory. </p>\n<p>Having carried out the build, we can safely remove any non-production dependencies from the <code class=\"language-text\">node_modules</code> folder. We do this using the command <code class=\"language-text\">npm prune --production</code>, which specifies that we only want to keep production dependencies. </p>\n<p>The second and final step of the Dockerfile is the one which will be used to create the image for our application. In here we simply copy the folders and files from the first step that we need: <code class=\"language-text\">package.json</code>, <code class=\"language-text\">package-lock.json</code>, <code class=\"language-text\">/dist</code>, and <code class=\"language-text\">/node_modules</code>. </p>\n<p>Finally, we run our command to start the production code in the container. </p>\n<h3>Creating a docker-compose file</h3>\n<p>Now, we’ll create a docker-compose file to help us with building our Docker image and passing any config that we need. </p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">touch</span> docker-compose.yml</code></pre></div>\n<p>Inside the file we can then add:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">version</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'3.2'</span>\n<span class=\"token key atrule\">services</span><span class=\"token punctuation\">:</span>\n  <span class=\"token key atrule\">nest-project</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">build</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">context</span><span class=\"token punctuation\">:</span> .\n      <span class=\"token key atrule\">dockerfile</span><span class=\"token punctuation\">:</span> <span class=\"token string\">'Dockerfile'</span>\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token string\">'3000:3000'</span></code></pre></div>\n<p>This specifies the service name, and the source of the Dockerfile (in this case, ‘Dockerfile’). It also maps the port of the application (3000) to an external port 3000. If we wanted to expose a different port then we could update this. e.g. <code class=\"language-text\">- &#39;4000:3000&#39;</code> would expose port 4000 for us to access the application on. </p>\n<p>We can now build the image using the following command:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">docker-compose up -d --build nest-project</code></pre></div>\n<p>This might take some time.\nOnce complete, you should be able to access your NestJS app on <a href=\"localhost:3000\">localhost:3000</a>, served from within the Docker container. </p>\n<h2>Summary</h2>\n<p>In just a few steps we’ve been able to Dockerise a simple NestJS app. This can help to simplify the process of deploying your production-code, or sharing the application with a friend to run locally.</p>","frontmatter":{"title":"NestJS Project in Docker","tags":["Docker","NestJS"],"date":"February 03, 2022","description":null}},"previous":{"fields":{"slug":"/alternative-to-npm-link/"},"frontmatter":{"title":"Alternative to NPM Link"}},"next":{"fields":{"slug":"/http-logging-with-morgan-and-winston/"},"frontmatter":{"title":"HTTP Logging with Morgan and Winston"}}},"pageContext":{"id":"dc88b96a-dac8-5934-8341-f3ce99217575","previousPostId":"3ab68165-fc86-5cec-be74-113ffa10052c","nextPostId":"ba0db2cd-c432-5801-8c3f-06171918a2f1"}},"staticQueryHashes":["230163734","2841359383"]}